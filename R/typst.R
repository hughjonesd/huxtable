# Typst printing ------------------------------------------------------------------

#' @export
#'
#' @rdname to_typst
print_typst <- function(ht, ...) {
  cat(to_typst(ht, ...))
}


#' Create Typst markup representing a huxtable
#'
#' These functions print or return a Typst table.
#'
#' @param ht A huxtable.
#' @param ... Arguments passed to methods. Not currently used.
#'
#' @return `to_typst` returns a Typst string. `print_typst` prints the string and returns `NULL`.
#' @export
#'
#' @family printing functions
#'
#' @examples
#' ht <- huxtable(a = 1:3, b = letters[1:3])
#' to_typst(ht)
to_typst <- function(ht, ...) {
  if (!check_positive_dims(ht)) {
    return("")
  }

  contents <- clean_contents(ht, output_type = "latex")
  shadow <- matrix(display_cells(ht)$shadowed, nrow(ht), ncol(ht))

  col_w <- col_width(ht)
  if (is.numeric(col_w)) {
    col_w_str <- ifelse(is.na(col_w), "auto", paste0(col_w, "fr"))
  } else {
    col_w_str <- ifelse(is.na(col_w), "auto", col_w)
  }

  table_opts <- typst_table_options(ht, col_w_str)
  table_start <- paste0("#table(\n  ", paste(table_opts, collapse = ",\n  "), "\n)[\n")

  cells <- matrix("", nrow(ht), ncol(ht))

  for (row in seq_len(nrow(ht))) {
    for (col in seq_len(ncol(ht))) {
      if (!shadow[row, col]) {
        cells[row, col] <- typst_cell(
          ht = ht,
          row = row,
          col = col,
          content = contents[row, col]
        )
      }
    }
  }

  row_strings <- apply(cells, 1, function(x) paste(x[x != ""], collapse = " "))

  hr <- header_rows(ht)
  hc <- header_cols(ht)

  header_block <- ""
  if (any(hr)) {
    header_rows_strings <- row_strings[hr]
    header_block <- paste0(
      "  table.header[\n",
      paste0("    ", header_rows_strings, collapse = "\n"),
      "\n  ]\n"
    )
    row_strings <- row_strings[!hr]
  }

  header_cols_block <- ""
  if (any(hc)) {
    col_strings <- apply(cells[, hc, drop = FALSE], 1, function(x) paste(x[x != ""], collapse = " "))
    header_cols_block <- paste0(
      "  table.header(columns: (", paste(hc, collapse = ", "), "))[\n",
      paste0("    ", col_strings, collapse = "\n"),
      "\n  ]\n"
    )
  }

  result <- paste0(
    table_start,
    header_block,
    header_cols_block,
    paste0("  ", row_strings, collapse = "\n"),
    "\n]\n"
  )
  result
}

# helpers -----------------------------------------------------------------------

#' @noRd
typst_table_options <- function(ht, col_w_str) {
  table_opts <- c(paste0("columns: (", paste(col_w_str, collapse = ", "), ")"))

  w <- width(ht)
  if (!is.na(w)) {
    if (is.numeric(w)) w <- sprintf("%.3f%%", w * 100)
    table_opts <- c(table_opts, sprintf("width: %s", w))
  }

  h <- height(ht)
  if (!is.na(h)) {
    if (is.numeric(h)) h <- sprintf("%.3f%%", h * 100)
    table_opts <- c(table_opts, sprintf("height: %s", h))
  }

  pos <- position(ht)
  if (!is.na(pos) && pos %in% c("left", "right")) {
    align <- pos
    table_opts <- c(table_opts, sprintf("align: %s", align))
  }

  lab <- make_label(ht)
  cap_raw <- caption(ht)
  if (!is.na(cap_raw)) {
    cap <- make_caption(ht, lab, "latex")

    fig_opts <- c(sprintf("caption: [%s]", cap))

    cp <- caption_pos(ht)
    if (!is.na(cp)) {
      vpos <- if (grepl("top", cp)) "top" else "bottom"
      fig_opts <- c(fig_opts, sprintf("position: %s", vpos))
    }

    cw <- caption_width(ht)
    if (!is.na(cw)) {
      if (is.numeric(cw)) cw <- sprintf("%.3f%%", cw * 100)
      table_opts <- c(table_opts, sprintf("caption-width: %s", cw))
    }

    table_opts <- c(table_opts, sprintf("figure: (%s)", paste(fig_opts, collapse = ", ")))
  }

  table_opts
}

#' @noRd
typst_cell <- function(ht, row, col, content) {
  opts <- typst_cell_options(ht = ht, row = row, col = col)
  text <- typst_cell_text(ht, row, col, content)
  cell_opts <- if (length(opts) > 0) {
    sprintf("(%s)", paste(opts, collapse = ", "))
  } else {
    ""
  }
  sprintf("cell%s[%s]", cell_opts, text)
}

#' @noRd
typst_cell_options <- function(ht, row, col) {
  opts <- c()

  rowspan <- rowspan(ht)[row, col]
  colspan <- colspan(ht)[row, col]
  if (rowspan > 1) opts <- c(opts, sprintf("rowspan: %d", rowspan))
  if (colspan > 1) opts <- c(opts, sprintf("colspan: %d", colspan))

  horizontal_align <- real_align(ht)[row, col]
  vertical_align <- valign(ht)[row, col]
  vertical_align <- c(top = "top", middle = "horizon", bottom = "bottom")[vertical_align]
  if (!is.na(vertical_align)) {
    opts <- c(opts, sprintf("align: (%s + %s)", horizontal_align, vertical_align))
  } else if (!is.na(horizontal_align)) {
    opts <- c(opts, sprintf("align: %s", horizontal_align))
  }

  row_height <- row_height(ht)[row]
  if (!is.na(row_height)) {
    rh <- row_height
    if (is.numeric(rh)) rh <- sprintf("%.3f%%", rh * 100)
    opts <- c(opts, sprintf("height: %s", rh))
  }

  bg <- background_color(ht)[row, col]
  if (!is.na(bg)) {
    opts <- c(opts, sprintf("fill: rgb(%s)", format_color(bg)))
  }

  pads <- c(
    top    = top_padding(ht)[row, col],
    right  = right_padding(ht)[row, col],
    bottom = bottom_padding(ht)[row, col],
    left   = left_padding(ht)[row, col]
  )
  default_pad <- 6
  if (!all(is.na(pads)) && any(pads != default_pad)) {
    if (length(unique(pads)) == 1) {
      opts <- c(opts, sprintf("inset: %.4gpt", pads[[1]]))
    } else {
      pad_parts <- sprintf("%s: %.4gpt", names(pads), pads)
      pad_parts <- pad_parts[!is.na(pads)]
      opts <- c(opts, sprintf("inset: (%s)", paste(pad_parts, collapse = ", ")))
    }
  }

  stroke <- typst_stroke(ht, row, col)
  if (length(stroke)) opts <- c(opts, stroke)

  opts
}

#' @noRd
typst_stroke <- function(ht, row, col) {
  tb <- brdr_thickness(top_border(ht))[row, col]
  rb <- brdr_thickness(right_border(ht))[row, col]
  bb <- brdr_thickness(bottom_border(ht))[row, col]
  lb <- brdr_thickness(left_border(ht))[row, col]
  tbs <- top_border_style(ht)[row, col]
  rbs <- right_border_style(ht)[row, col]
  bbs <- bottom_border_style(ht)[row, col]
  lbs <- left_border_style(ht)[row, col]
  tbc <- format_color(top_border_color(ht)[row, col], default = "black")
  rbc <- format_color(right_border_color(ht)[row, col], default = "black")
  bbc <- format_color(bottom_border_color(ht)[row, col], default = "black")
  lbc <- format_color(left_border_color(ht)[row, col], default = "black")

  stroke_parts <- c()
  if (tb > 0) stroke_parts <- c(stroke_parts, sprintf("top: %.4gpt + %s + rgb(%s)", tb, tbs, tbc))
  if (rb > 0) stroke_parts <- c(stroke_parts, sprintf("right: %.4gpt + %s + rgb(%s)", rb, rbs, rbc))
  if (bb > 0) stroke_parts <- c(stroke_parts, sprintf("bottom: %.4gpt + %s + rgb(%s)", bb, bbs, bbc))
  if (lb > 0) stroke_parts <- c(stroke_parts, sprintf("left: %.4gpt + %s + rgb(%s)", lb, lbs, lbc))

  if (length(stroke_parts) > 0) {
    sprintf("stroke: (%s)", paste(stroke_parts, collapse = ", "))
  } else {
    NULL
  }
}

#' @noRd
typst_cell_text <- function(ht, row, col, cell_text) {
  text_opts <- c()
  if (bold(ht)[row, col]) text_opts <- c(text_opts, "weight: \"bold\"")
  if (italic(ht)[row, col]) text_opts <- c(text_opts, "style: \"italic\"")
  if (!is.na(fs <- font_size(ht)[row, col])) text_opts <- c(text_opts, sprintf("size: %.4gpt", fs))
  if (!is.na(f <- font(ht)[row, col])) text_opts <- c(text_opts, sprintf("family: \"%s\"", f))
  if (!is.na(tc <- text_color(ht)[row, col])) text_opts <- c(text_opts, sprintf("fill: rgb(%s)", format_color(tc)))


  if (length(text_opts) > 0) {
    text <- sprintf("#text(%s)[%s]", paste(text_opts, collapse = ", "), cell_text)
  } else {
    text <- cell_text
  }

  if (!wrap(ht)[row, col]) {
    text <- sprintf("#box(breakable: false)[%s]", text)
  }

  text
}
