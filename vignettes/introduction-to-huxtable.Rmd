---
title: "Introduction to Huxtable"
author: "David Hugh-Jones"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to Huxtable}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, echo = FALSE}

library(knitr)
knitr::opts_chunk$set(results = 'asis')
is_latex <- knitr::opts_knit$get('rmarkdown.pandoc.to') == 'latex'

```



Huxtable is a package for writing LaTeX and HTML tables. It is powerful, but easy to use. It is meant to be a
replacement for packages like xtable, which is useful but not always very user-friendly.

To create a table with huxtable, use the function `huxtable`, or `hux` for short.

```{r}
library(huxtable)
ht <- hux(Employee = c('John Smith', 'Jane Doe', 'David Hugh-Jones'), Salary = c(50000, 50000, 40000),
      add_colnames = TRUE)
```


Or, if you already have your data in a data frame, use `as_hux`.

```{r}
data(mtcars)
car_ht <- as_hux(mtcars)
```

Huxtables are simply data frames, along with some extra information on how to display them. If you look at them in R,
they'll appear just like ordinary data frames. Notice that we've added the column names to the data frame itself.
We're going to print them out, so it makes sense that they need to be part of the actual table.

```{r, results = 'markup'}
print(ht)
```

To print them out using LaTeX or HTML, just call `print_latex` or `print_html`. 

```{r}
if (is_latex) print_latex(ht) else print_html(ht)
```

The default output is a very plain table. To customize it, you can set various properties. Let's make our table headings bold, draw a line under the header row, and align the second row to the right:


```{r}
# Define a function that prints in the appropriate output format
print_out <- if (is_latex) print_latex else print_html    

bold(ht)[1,]           <- TRUE
bottom_border(ht)[1,]  <- TRUE
align(ht)[,2]        <- 'right'
right_padding(ht)      <- 10
left_padding(ht)       <- 10

print_out(ht)
```

You set properties by assigning to the property name, just as you assign `names(x) <- new_names` in base R.

Some properties, like `bold` and `bottom_border`, are cell-level. You can set them for individual cells in your
data. For example, the line `bold(ht)[1,] <- TRUE` in the code above sets the `bold` property for the first row
of the huxtable. And `align(ht)[,2] <- 'right'` sets the alignment for the second column.

In fact, `right_padding` and `left_padding` are also cell-level properties. But we set them for all cells at once. You can do that for any property - just do `property(ht) <- value`.

By contrast, `caption` is a table-level property. It only takes one value, which sets a table caption.

```{r}

caption(ht) <- 'Employee table'

print_out(ht)

```

See the help files for a list of all properties you can set. Most properties work the same for LaTeX and HTML,
though there are some exceptions.

## Pipe style syntax

If you prefer to use the `magrittr` pipe operator (`%>%`), then you can do that too using `set_property` functions:


```{r}

library(dplyr)
ht %>% 
      set_bold(1, 1:2, TRUE)          %>% 
      set_bottom_border(1, 1:2, 1)    %>%
      set_align(-1, 2, 'right')       %>%
      set_right_padding(1:4, 1:2, 10) %>%
      set_left_padding(1:4, 1:2, 10)  %>%
      print_out

```

To see the current properties of a huxtable, just use the properties function without the left arrow:

```{r, results = 'markup'}
italic(ht)
position(ht)
bottom_border(ht)[1:2,] # first two rows
```

## Subsetting a huxtable

You can subset, sort and generally data-wrangle a huxtable just like a normal data frame.

```{r}

automatics <- car_ht[car_ht$am == 1,]
print_out(automatics[1:5,])

cars_mpg <- car_ht[, c('mpg', 'cyl', 'am')]

cars_mpg <- cars_mpg[order(cars_mpg$cyl),]

cars_mpg <- cars_mpg %>% 
      huxtable::add_rownames(colname = 'Car Name') %>% 
      huxtable::add_colnames() 
    

print_out(cars_mpg[1:5,])
```

However, in general it is a good idea to prepare your data first, before styling it. For example, it was easier to sort the `cars_mpg` data by cylinder before adding column names to the data frame itself.

## Colspan and rowspan

As well as changing styling, you can let cells span multiple rows or columns.

```{r}
cars_mpg <- cbind(car_type = rep("", nrow(cars_mpg)), cars_mpg)
cars_mpg$car_type[1] <- 'Four cylinders'
cars_mpg$car_type[13] <- 'Six cylinders'
cars_mpg$car_type[20] <- 'Eight cylinders'
rowspan(cars_mpg)[1, 1] <- 12
rowspan(cars_mpg)[13, 1] <- 7
rowspan(cars_mpg)[20, 1] <- 14

bottom_border(cars_mpg)[c(1, 13, 20)] <- 1
right_border(cars_mpg)[,1] <- 1

print_out(cars_mpg)
```

## Number formatting

You can change how huxtable formats numbers using `number_format`. Huxtable guesses whether your cell is a number
based on its contents, not on the column type. Set `number_format` to a number of decimal places (for more advanced
options, see the help files).

```{r}
number_format(cars_mpg) <- 0
print_out(cars_mpg[1:7,])
```

## Quick themes

Huxtable comes with predefined themes that change various parts of formatting:

```{r}
print_out(theme_minimal(cars_mpg[1:12,]))
print_out(theme_striped(cars_mpg[13:19,], stripe = 'bisque1', header_col = FALSE, header_row = FALSE))
```


## Printing on screen

Lastly, you can print a huxtable on screen using `print_screen`. Borders, column and row spans and cell alignment are shown:

```{r, results = 'markup'}

print_screen(ht)
```

